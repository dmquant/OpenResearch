import { v4 as uuidv4 } from 'uuid';

export class ProjectService {
  constructor(db) {
    this.db = db;
  }

  /**
   * Create a new research project
   */
  async createProject({ title, description, topic, userId = null }) {
    try {
      const projectId = uuidv4();
      const now = new Date().toISOString();

      const result = await this.db
        .prepare(`
          INSERT INTO projects (id, title, description, topic, status, created_at, updated_at, user_id)
          VALUES (?, ?, ?, ?, 'planning', ?, ?, ?)
        `)
        .bind(projectId, title, description, topic, now, now, userId)
        .run();

      if (!result.success) {
        throw new Error('Failed to create project');
      }

      return this.getProject(projectId);
    } catch (error) {
      console.error('Error creating project:', error);
      throw new Error(`Failed to create project: ${error.message}`);
    }
  }

  /**
   * Get project by ID with related data
   */
  async getProject(projectId) {
    try {
      const project = await this.db
        .prepare('SELECT * FROM projects WHERE id = ?')
        .bind(projectId)
        .first();

      if (!project) return null;

      // Get research plan
      const plan = await this.db
        .prepare('SELECT * FROM research_plans WHERE project_id = ? ORDER BY created_at DESC LIMIT 1')
        .bind(projectId)
        .first();

      // Get tasks
      const tasks = await this.db
        .prepare('SELECT * FROM tasks WHERE project_id = ? ORDER BY created_at')
        .bind(projectId)
        .all();

      // Get cards
      const cards = await this.db
        .prepare('SELECT * FROM cards WHERE project_id = ? ORDER BY created_at')
        .bind(projectId)
        .all();

      return {
        ...project,
        plan: plan ? { ...plan, plan_data: JSON.parse(plan.plan_data) } : null,
        tasks: tasks.results || [],
        cards: cards.results || []
      };
    } catch (error) {
      console.error('Error getting project:', error);
      throw new Error(`Failed to get project: ${error.message}`);
    }
  }

  /**
   * Get all projects for a user
   */
  async getAllProjects(userId = null) {
    try {
      let query = 'SELECT * FROM projects ORDER BY created_at DESC';
      let stmt;

      if (userId) {
        query = 'SELECT * FROM projects WHERE user_id = ? ORDER BY created_at DESC';
        stmt = this.db.prepare(query).bind(userId);
      } else {
        stmt = this.db.prepare(query);
      }

      const result = await stmt.all();
      return result.results || [];
    } catch (error) {
      console.error('Error getting projects:', error);
      throw new Error(`Failed to get projects: ${error.message}`);
    }
  }

  /**
   * Store research plan (generated by frontend)
   */
  async storeResearchPlan(projectId, planData) {
    try {
      // Store the plan
      const planId = uuidv4();
      const now = new Date().toISOString();

      await this.db
        .prepare(`
          INSERT INTO research_plans (id, project_id, title, description, plan_data, created_at, updated_at)
          VALUES (?, ?, ?, ?, ?, ?, ?)
        `)
        .bind(planId, projectId, planData.title, planData.description, JSON.stringify(planData), now, now)
        .run();

      // Create tasks
      for (const [index, task] of planData.tasks.entries()) {
        const taskId = uuidv4();
        await this.db
          .prepare(`
            INSERT INTO tasks (id, project_id, plan_id, title, description, query, task_type, priority, created_at, updated_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          `)
          .bind(taskId, projectId, planId, task.title, task.description, task.query, task.type, index, now, now)
          .run();
      }

      // Update project status
      await this.db
        .prepare('UPDATE projects SET status = ?, updated_at = ? WHERE id = ?')
        .bind('planned', now, projectId)
        .run();

      return {
        id: planId,
        project_id: projectId,
        title: planData.title,
        description: planData.description,
        plan_data: planData,
        created_at: now,
        updated_at: now
      };
    } catch (error) {
      console.error('Error storing research plan:', error);
      throw new Error(`Failed to store research plan: ${error.message}`);
    }
  }

  /**
   * Store card (generated by frontend)
   */
  async storeCard(projectId, cardData) {
    try {
      const cardId = uuidv4();
      const now = new Date().toISOString();

      await this.db
        .prepare(`
          INSERT INTO cards (id, project_id, task_id, title, card_type, content, raw_content, summary, metadata, embedding_stored, created_at, updated_at)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `)
        .bind(
          cardId,
          projectId,
          cardData.taskId || null,
          cardData.title,
          cardData.type || 'text_summary',
          cardData.content,
          cardData.raw_content || cardData.content,
          cardData.summary || null,
          JSON.stringify(cardData.metadata || {}),
          !!cardData.embedding,
          now,
          now
        )
        .run();

      return {
        id: cardId,
        project_id: projectId,
        task_id: cardData.taskId,
        title: cardData.title,
        card_type: cardData.type || 'text_summary',
        content: cardData.content,
        raw_content: cardData.raw_content || cardData.content,
        summary: cardData.summary,
        metadata: cardData.metadata || {},
        embedding_stored: !!cardData.embedding,
        created_at: now,
        updated_at: now
      };
    } catch (error) {
      console.error('Error storing card:', error);
      throw new Error(`Failed to store card: ${error.message}`);
    }
  }

  /**
   * Store report (generated by frontend)
   */
  async storeReport(projectId, reportData) {
    try {
      const reportId = uuidv4();
      const now = new Date().toISOString();

      await this.db
        .prepare(`
          INSERT INTO reports (id, project_id, title, content, language, report_type, selected_cards, metadata, created_at, updated_at)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `)
        .bind(
          reportId,
          projectId,
          reportData.title,
          reportData.content,
          reportData.language || 'english',
          reportData.report_type || 'comprehensive',
          JSON.stringify(reportData.selected_cards || []),
          JSON.stringify(reportData.metadata || {}),
          now,
          now
        )
        .run();

      // Update project status to completed when report is successfully stored
      await this.db
        .prepare('UPDATE projects SET status = ?, updated_at = ? WHERE id = ?')
        .bind('completed', now, projectId)
        .run();

      console.log(`✅ Project ${projectId} status updated to 'completed' after report generation`);

      return {
        id: reportId,
        project_id: projectId,
        title: reportData.title,
        content: reportData.content,
        language: reportData.language || 'english',
        report_type: reportData.report_type || 'comprehensive',
        selected_cards: reportData.selected_cards || [],
        metadata: reportData.metadata || {},
        created_at: now,
        updated_at: now
      };
    } catch (error) {
      console.error('Error storing report:', error);
      throw new Error(`Failed to store report: ${error.message}`);
    }
  }

  /**
   * Execute a research task using Gemini AI
   */
  async executeTask(taskId, geminiApiKey) {
    try {
      const task = await this.db
        .prepare('SELECT * FROM tasks WHERE id = ?')
        .bind(taskId)
        .first();

      if (!task) {
        throw new Error('Task not found');
      }

      // Update task status to running
      const now = new Date().toISOString();
      await this.db
        .prepare('UPDATE tasks SET status = ?, started_at = ?, updated_at = ? WHERE id = ?')
        .bind('running', now, now, taskId)
        .run();

      // Log execution start
      await this.logExecution(task.project_id, taskId, 'info', `Started task: ${task.title}`);

      const genai = new GoogleGenAI({ apiKey: geminiApiKey });
      const model = genai.getGenerativeModel({
        model: 'gemini-2.5-flash',
        tools: [{ googleSearch: {} }]
      });

      const prompt = `Research Task: ${task.title}
Description: ${task.description}
Query: ${task.query}

Please conduct thorough research on this topic and provide:
1. A comprehensive summary of findings
2. Key insights and analysis
3. Relevant data points and statistics
4. Sources and citations

Format your response as a detailed research card with citations.`;

      const result = await model.generateContent({
        contents: [{
          role: 'user',
          parts: [{ text: prompt }]
        }],
        generationConfig: {
          temperature: 0.7,
          maxOutputTokens: 4096,
        }
      });

      const content = result.response.text();
      
      // Create research card
      const cardId = uuidv4();
      const cardType = this.determineCardType(content);
      
      await this.db
        .prepare(`
          INSERT INTO cards (id, project_id, task_id, title, card_type, content, raw_content, summary, metadata, created_at, updated_at)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `)
        .bind(
          cardId,
          task.project_id,
          taskId,
          task.title,
          cardType,
          content,
          content,
          content.substring(0, 200) + '...',
          JSON.stringify({ confidence: 0.8, source: 'gemini-ai', taskType: task.task_type }),
          now,
          now
        )
        .run();

      // Update task status to completed
      await this.db
        .prepare('UPDATE tasks SET status = ?, completed_at = ?, updated_at = ? WHERE id = ?')
        .bind('completed', now, now, taskId)
        .run();

      // Log completion
      await this.logExecution(task.project_id, taskId, 'success', `Completed task: ${task.title}`);

      return {
        id: cardId,
        project_id: task.project_id,
        task_id: taskId,
        title: task.title,
        card_type: cardType,
        content: content,
        created_at: now
      };
    } catch (error) {
      console.error('Error executing task:', error);
      
      // Update task status to failed
      const now = new Date().toISOString();
      await this.db
        .prepare('UPDATE tasks SET status = ?, error_message = ?, updated_at = ? WHERE id = ?')
        .bind('failed', error.message, now, taskId)
        .run();

      // Log error
      await this.logExecution(task.project_id, taskId, 'error', `Task failed: ${error.message}`);
      
      throw error;
    }
  }

  /**
   * Get all cards for a project
   */
  async getProjectCards(projectId) {
    try {
      const cards = await this.db
        .prepare(`
          SELECT c.*, t.title as task_title, t.task_type 
          FROM cards c 
          LEFT JOIN tasks t ON c.task_id = t.id 
          WHERE c.project_id = ? 
          ORDER BY c.created_at
        `)
        .bind(projectId)
        .all();

      return cards.results || [];
    } catch (error) {
      console.error('Error getting project cards:', error);
      throw new Error(`Failed to get project cards: ${error.message}`);
    }
  }

  /**
   * Get all reports for a project
   */
  async getProjectReports(projectId) {
    try {
      const reports = await this.db
        .prepare(`
          SELECT * FROM reports 
          WHERE project_id = ? 
          ORDER BY created_at DESC
        `)
        .bind(projectId)
        .all();

      return reports.results || [];
    } catch (error) {
      console.error('Error getting project reports:', error);
      throw new Error(`Failed to get project reports: ${error.message}`);
    }
  }

  /**
   * Generate bilingual report using Gemini AI
   */
  async generateReport(projectId, { selectedCardIds, language = 'english' }, geminiApiKey) {
    try {
      // Get selected cards
      const placeholders = selectedCardIds.map(() => '?').join(',');
      const cards = await this.db
        .prepare(`SELECT * FROM cards WHERE id IN (${placeholders})`)
        .bind(...selectedCardIds)
        .all();

      const project = await this.db
        .prepare('SELECT * FROM projects WHERE id = ?')
        .bind(projectId)
        .first();

      const genai = new GoogleGenAI(geminiApiKey);
      const model = genai.getGenerativeModel({ model: 'gemini-2.5-flash' });

      const cardContents = cards.results.map(card => 
        `## ${card.title}\n\n${card.content}`
      ).join('\n\n---\n\n');

      const prompt = `Create a comprehensive research report based on the following research cards.

Project Topic: ${project.topic}
Language: ${language}

Research Cards:
${cardContents}

Please create a well-structured report in MDX format that:
1. Synthesizes the information from all cards
2. Provides clear sections and headings
3. Maintains academic rigor
4. Includes proper citations
5. Is written in ${language}

Format as MDX with proper frontmatter.`;

      const result = await model.generateContent({
        contents: [{
          role: 'user',
          parts: [{ text: prompt }]
        }],
        generationConfig: {
          temperature: 0.7,
          maxOutputTokens: 8192,
        }
      });

      const content = result.response.text();
      
      return {
        id: uuidv4(),
        title: `Research Report: ${project.title}`,
        content: content,
        language: language,
        report_type: 'comprehensive',
        selected_cards: JSON.stringify(selectedCardIds),
        created_at: new Date().toISOString()
      };
    } catch (error) {
      console.error('Error generating report:', error);
      throw new Error(`Failed to generate report: ${error.message}`);
    }
  }

  /**
   * Get specific report by ID
   */
  async getReport(projectId, reportId) {
    try {
      const report = await this.db
        .prepare('SELECT * FROM reports WHERE id = ? AND project_id = ?')
        .bind(reportId, projectId)
        .first();

      return report;
    } catch (error) {
      console.error('Error getting report:', error);
      throw new Error(`Failed to get report: ${error.message}`);
    }
  }

  /**
   * Update existing report
   */
  async updateReport(projectId, reportId, updateData) {
    try {
      const now = new Date().toISOString();
      
      // Build dynamic update query based on provided data
      const updateFields = [];
      const updateValues = [];
      
      if (updateData.title !== undefined) {
        updateFields.push('title = ?');
        updateValues.push(updateData.title);
      }
      
      if (updateData.content !== undefined) {
        updateFields.push('content = ?');
        updateValues.push(updateData.content);
      }
      
      if (updateData.language !== undefined) {
        updateFields.push('language = ?');
        updateValues.push(updateData.language);
      }
      
      if (updateData.report_type !== undefined) {
        updateFields.push('report_type = ?');
        updateValues.push(updateData.report_type);
      }
      
      // Always update the updated_at timestamp
      updateFields.push('updated_at = ?');
      updateValues.push(now);
      
      // Add the WHERE clause values
      updateValues.push(reportId, projectId);
      
      const query = `UPDATE reports SET ${updateFields.join(', ')} WHERE id = ? AND project_id = ?`;
      
      const result = await this.db
        .prepare(query)
        .bind(...updateValues)
        .run();

      if (!result.success) {
        throw new Error('Failed to update report');
      }

      // Return the updated report
      return await this.getReport(projectId, reportId);
    } catch (error) {
      console.error('Error updating report:', error);
      throw new Error(`Failed to update report: ${error.message}`);
    }
  }

  /**
   * Save report to database
   */
  async saveReport(projectId, report, r2Path = null) {
    try {
      await this.db
        .prepare(`
          INSERT INTO reports (id, project_id, title, content, language, report_type, selected_cards, r2_path, created_at, updated_at)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `)
        .bind(
          report.id,
          projectId,
          report.title,
          report.content,
          report.language,
          report.report_type,
          report.selected_cards,
          r2Path,
          report.created_at,
          report.created_at
        )
        .run();

      // Update project status to completed when report is successfully saved
      const now = new Date().toISOString();
      await this.db
        .prepare('UPDATE projects SET status = ?, updated_at = ? WHERE id = ?')
        .bind('completed', now, projectId)
        .run();

      console.log(`✅ Project ${projectId} status updated to 'completed' after report save`);

      return report;
    } catch (error) {
      console.error('Error saving report:', error);
      throw new Error(`Failed to save report: ${error.message}`);
    }
  }

  /**
   * Export project data
   */
  async exportProject(projectId) {
    try {
      const project = await this.getProject(projectId);
      
      if (!project) {
        throw new Error('Project not found');
      }

      // Get reports
      const reports = await this.db
        .prepare('SELECT * FROM reports WHERE project_id = ?')
        .bind(projectId)
        .all();

      // Get execution logs
      const logs = await this.db
        .prepare('SELECT * FROM execution_logs WHERE project_id = ? ORDER BY created_at')
        .bind(projectId)
        .all();

      return {
        project,
        reports: reports.results || [],
        logs: logs.results || [],
        exported_at: new Date().toISOString()
      };
    } catch (error) {
      console.error('Error exporting project:', error);
      throw new Error(`Failed to export project: ${error.message}`);
    }
  }

  /**
   * Log execution events
   */
  async logExecution(projectId, taskId, level, message, details = null) {
    try {
      await this.db
        .prepare(`
          INSERT INTO execution_logs (project_id, task_id, log_level, message, details, created_at)
          VALUES (?, ?, ?, ?, ?, ?)
        `)
        .bind(projectId, taskId, level, message, details ? JSON.stringify(details) : null, new Date().toISOString())
        .run();
    } catch (error) {
      console.error('Error logging execution:', error);
    }
  }

  /**
   * Determine card type based on content
   */
  determineCardType(content) {
    const lowerContent = content.toLowerCase();
    
    if (lowerContent.includes('table') || lowerContent.includes('|')) {
      return 'table';
    } else if (lowerContent.includes('chart') || lowerContent.includes('graph')) {
      return 'chart';
    } else if (lowerContent.includes('"') && lowerContent.includes('said')) {
      return 'quote';
    } else {
      return 'text_summary';
    }
  }

  /**
   * Mark a card as having its embedding stored
   */
  async markCardEmbeddingStored(cardId) {
    try {
      await this.db
        .prepare(`
          UPDATE cards 
          SET embedding_stored = true, updated_at = ?
          WHERE id = ?
        `)
        .bind(new Date().toISOString(), cardId)
        .run();
      
      return { success: true };
    } catch (error) {
      console.error('Error marking card embedding as stored:', error);
      throw error;
    }
  }
}